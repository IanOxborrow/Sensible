diff --git a/TestProject/App.js b/TestProject/App.js
index 4bd2a89f..1f3efd87 100644
--- a/TestProject/App.js
+++ b/TestProject/App.js
@@ -32,10 +32,12 @@ import { Text } from "react-native";
 import { SensorType } from "./src/Sensors";
 import Recording from "./src/Recording";
 import MainStackNavigator from './src/navigation/MainStackNavigator'
+import { DownloadDirectoryPath } from "react-native-fs";
 
 export default class App extends React.Component
 {
     static recording = null;
+    static SAVE_FILE_PATH = DownloadDirectoryPath + '/';
 
     constructor(props)
     {
@@ -49,9 +51,9 @@ export default class App extends React.Component
         App.recording = new Recording();
         App.recording.addSensor(SensorType.ACCELEROMETER);
         App.recording.addSensor(SensorType.GYROSCOPE);
-        App.recording.addSensor(SensorType.MAGNETOMETER);
-        App.recording.addSensor(SensorType.BAROMETER);
-        App.recording.addSensor(SensorType.MICROPHONE);
+        // App.recording.addSensor(SensorType.MAGNETOMETER);
+        // App.recording.addSensor(SensorType.BAROMETER);
+        // App.recording.addSensor(SensorType.MICROPHONE);
 
 
         // setInterval(function () {
diff --git a/TestProject/src/Recording.js b/TestProject/src/Recording.js
index 5e12a9b0..c5c02741 100644
--- a/TestProject/src/Recording.js
+++ b/TestProject/src/Recording.js
@@ -1,11 +1,34 @@
 /* eslint-disable prettier/prettier */
-import { Accelerometer, SensorType, GenericTimeframe, Mic, Gyroscope, Magnetometer, Barometer } from "./Sensors";
-import Label from "./sensors/Label"
-import {PermissionsAndroid, Platform} from "react-native";
+import {
+    Accelerometer,
+    SensorType,
+    GenericTimeframe,
+    Mic,
+    Gyroscope,
+    Magnetometer,
+    Barometer,
+    SensorClass, getSensorClass, getSensorFileName,
+} from "./Sensors";
+import Label from './sensors/Label';
+import {PermissionsAndroid, Platform} from 'react-native';
 import {PERMISSIONS, check, request, RESULTS} from 'react-native-permissions';
+import {
+    mkdir,
+    writeFile,
+    appendFile,
+    DocumentDirectoryPath,
+    readDir,
+    readFile,
+    exists,
+    unlink,
+} from "react-native-fs";
+import App from '../App';
 
 export default class Recording {
     constructor() {
+        this.name = 'Recording1';
+        // this.folderPath = App.SAVE_FILE_PATH + this.name.replace(/ /g, '_') + '/';
+        this.folderPath = App.SAVE_FILE_PATH;
         this.sampleRate = 40000; // in Hz
         this.bufferSize = 5; // The number of samples to store in the buffer before saving all of them to file at once
         this.timeframeSize = 10; // The number of samples in a timeframe. Additional points will be saved to file.
@@ -13,6 +36,75 @@ export default class Recording {
         this.graphableData = {};
         this.logicalTime = 0;
         this.labels = [];
+
+        // Create a folder for the current instance
+        // TODO: Don't go to any other screen until this has been done
+        mkdir(this.folderPath)
+            .then(suc => { console.log('Successfully created ' + this.folderPath); })
+            .catch(err => {
+                throw new Error(this.constructor.name + '.constructor: Failed to create the recording directory');
+            });
+
+        // Delete the existing metadata file and create a new one
+        const infoFilePath = this.folderPath + 'info.txt';
+        exists(infoFilePath)
+            .then(fileExists => {
+                if (fileExists)
+                {
+                    unlink(infoFilePath).catch(() => {});
+                }
+            })
+            .catch(() => {})
+            .finally(() => {
+                // Create the metadata file
+                writeFile(infoFilePath, 'Recording name: ' + this.name, 'utf8')
+                    .then(() => {
+                        console.log('Successfully created ' + infoFilePath);
+                    })
+                    .catch(() => {
+                        throw new Error(this.constructor.name + '.initialiseGenericSensor: Failed to create metadata file');
+                    });
+            });
+    }
+
+    /**
+     * Initialise a new sensor and a generic timeframe
+     * @param type The type of the sensor to initialise
+     */
+    initialiseGenericSensor(type)
+    {
+        const sensorClass = getSensorClass(type);
+        const sensorFile = this.folderPath + getSensorFileName(type);
+        // Create the timeframe array for the sensor (with an initial timeframe)
+        this.graphableData[type] = [new GenericTimeframe(this, this.timeframeSize, this.bufferSize, type)];
+        // Create a new sensor instance to track and enable it
+        this.enabledSensors[type] = new sensorClass(this.graphableData[type], this.sampleRate);
+
+        // Delete any existing file
+        exists(sensorFile)
+            .then(fileExists => {
+                if (fileExists)
+                {
+                    unlink(sensorFile).catch(() => {});
+                }
+            })
+            .catch(() => {})
+            .finally(() => {
+                // Create a file to store the data
+                writeFile(sensorFile, '', 'utf8')
+                    .then(() => {
+                        console.log('Successfully created ' + this.folderPath + sensorClass.prototype.constructor.name + '.csv');
+                    }) // TODO: Don't go to any other screen until this has been done
+                    .catch(() => {
+                        throw new Error(this.constructor.name + '.initialiseGenericSensor: Failed to create sensor file');
+                    });
+            });
+
+        // TODO: Remove this
+        // readFile(sensorFile, 'utf8')
+        //     .then(content => {
+        //         console.log(sensorFile + " - " + content);
+        //     });
     }
 
     /**
@@ -24,28 +116,16 @@ export default class Recording {
         switch (type)
         {
             case SensorType.ACCELEROMETER:
-                // Create the timeframe array for the accelerometer (with an initial timeframe)
-                this.graphableData[type] = [new GenericTimeframe(this.timeframeSize, this.bufferSize)];
-                // Create a new accelerometer instance to track and enable it
-                this.enabledSensors[type] = new Accelerometer(this.graphableData[type], this.sampleRate);
+                this.initialiseGenericSensor(SensorType.ACCELEROMETER);
                 break;
             case SensorType.GYROSCOPE:
-                // Create the timeframe array for the gyroscope (with an initial timeframe)
-                this.graphableData[type] = [new GenericTimeframe(this.timeframeSize, this.bufferSize)];
-                // Create a new gyroscope instance to track and enable it
-                this.enabledSensors[type] = new Gyroscope(this.graphableData[type], this.sampleRate);
+                this.initialiseGenericSensor(SensorType.GYROSCOPE);
                 break;
             case SensorType.MAGNETOMETER:
-                // Create the timeframe array for the magnetometer (with an initial timeframe)
-                this.graphableData[type] = [new GenericTimeframe(this.timeframeSize, this.bufferSize)];
-                // Create a new magnetometer instance to track and enable it
-                this.enabledSensors[type] = new Magnetometer(this.graphableData[type], this.sampleRate);
+                this.initialiseGenericSensor(SensorType.MAGNETOMETER);
                 break;
             case SensorType.BAROMETER:
-                // Create the timeframe array for the magnetometer (with an initial timeframe)
-                this.graphableData[type] = [new GenericTimeframe(this.timeframeSize, this.bufferSize)];
-                // Create a new barometer instance to track and enable it
-                this.enabledSensors[type] = new Barometer(this.graphableData[type], this.sampleRate);
+                this.initialiseGenericSensor(SensorType.BAROMETER);
                 break;
             case SensorType.MICROPHONE:
                 // console.warn('Recording.addSensor(SensorType.MICROPHONE) has not been implemented');
@@ -55,26 +135,26 @@ export default class Recording {
                     if (Platform.OS === 'ios') {
                         const granted = await check(PERMISSIONS.IOS.MICROPHONE);
                         if (granted == RESULTS.GRANTED) {
-                            console.log("iOS - You can use the microphone")
+                            console.log('iOS - You can use the microphone');
                         }
                     } else {
                         try {
                             const granted = await PermissionsAndroid.request(
                                 PermissionsAndroid.PERMISSIONS.RECORD_AUDIO,
                                 {
-                                    title: "Microphone Permission",
+                                    title: 'Microphone Permission',
                                     message:
-                                        "This app needs access to your microphone " +
-                                        "in order to collect microphone data",
-                                    buttonNeutral: "Ask Me Later",
-                                    buttonNegative: "Cancel",
-                                    buttonPositive: "OK"
+                                        'This app needs access to your microphone ' +
+                                        'in order to collect microphone data',
+                                    buttonNeutral: 'Ask Me Later',
+                                    buttonNegative: 'Cancel',
+                                    buttonPositive: 'OK',
                                 }
                             );
                             if (granted === PermissionsAndroid.RESULTS.GRANTED) {
-                                console.log("You can use the microphone");
+                                console.log('You can use the microphone');
                             } else {
-                                console.log("Microphone permission denied");
+                                console.log('Microphone permission denied');
                             }
                         } catch (err) {
                             console.warn(err);
@@ -83,9 +163,7 @@ export default class Recording {
                 };
 
                 requestMicPermission();
-
-                this.graphableData[type] = [new GenericTimeframe(this.timeframeSize, this.bufferSize)];
-                this.enabledSensors[type] = new Mic(this.graphableData[type], this.sampleRate);;
+                this.initialiseGenericSensor(SensorType.MICROPHONE);
 
                 break;
             default:
@@ -124,8 +202,8 @@ export default class Recording {
         // Throw an error if the sensor hasn't been initialised
         if (this.graphableData[type] == null)
         {
-            throw new Error("Recording.getSensorData: Attempted to get sensor data for type-" + type +
-                " but it has not been initialised correctly if at all.");
+            throw new Error('Recording.getSensorData: Attempted to get sensor data for type-' + type +
+                ' but it has not been initialised correctly if at all.');
         }
 
         let sensorData = this.graphableData[type];
diff --git a/TestProject/src/Sensors.js b/TestProject/src/Sensors.js
index c224cd58..08d12831 100644
--- a/TestProject/src/Sensors.js
+++ b/TestProject/src/Sensors.js
@@ -1,4 +1,10 @@
 /* eslint-disable prettier/prettier */
+import Accelerometer from './sensors/Accelerometer';
+import Gyroscope from './sensors/Gyroscope';
+import Magnetometer from './sensors/Magnetometer';
+import Barometer from './sensors/Barometer';
+import Mic from './sensors/Mic';
+
 export {default as GenericTimeframe} from './sensors/GenericTimeframe';
 export {default as Accelerometer} from './sensors/Accelerometer';
 export {default as AccelerometerSample} from './sensors/AccelerometerSample';
@@ -9,6 +15,7 @@ export {default as BarometerSample} from './sensors/BarometerSample';
 export {default as Magnetometer} from './sensors/Magnetometer';
 export {default as MagnetometerSample} from './sensors/MagnetometerSample';
 export {default as Mic} from './sensors/Mic';
+export {default as MicSample} from './sensors/MicSample';
 export const SensorType = {
     ACCELEROMETER: 0,
     GYROSCOPE: 1,
@@ -16,3 +23,23 @@ export const SensorType = {
     BAROMETER: 3,
     MICROPHONE: 4,
 };
+export const getSensorClass = (type) => {
+    switch (type)
+    {
+        case SensorType.ACCELEROMETER:
+            return Accelerometer;
+        case SensorType.GYROSCOPE:
+            return Gyroscope;
+        case SensorType.MAGNETOMETER:
+            return Magnetometer;
+        case SensorType.BAROMETER:
+            return Barometer;
+        case SensorType.MICROPHONE:
+            return Mic;
+        default:
+            throw new Error('Sensors.getSensorClass: Received an unknown type');
+    }
+};
+export const getSensorFileName = (type) => {
+    return getSensorClass(type).prototype.constructor.name + '.txt';
+};
diff --git a/TestProject/src/errors/ErrorChecking.js b/TestProject/src/errors/ErrorChecking.js
index 9fa88404..fcde7783 100644
--- a/TestProject/src/errors/ErrorChecking.js
+++ b/TestProject/src/errors/ErrorChecking.js
@@ -65,8 +65,10 @@ export default class ErrorChecking
                   interfaceName + "." + f.name + "(" + got + ")";
 
                 // Do a simple check of the number of parameters
-                if (expected.length !== got.length)
+                if (expected.length !== got.length && f.name !== "constructor")
+                {
                     throw new InconsistentParametersError(errorMessage);
+                }
                 // Otherwise check that each parameter name matches that of the interface
                 else
                 {
diff --git a/TestProject/src/screens/NewRecordingScreen.js b/TestProject/src/screens/NewRecordingScreen.js
index 9156caa3..77516a97 100644
--- a/TestProject/src/screens/NewRecordingScreen.js
+++ b/TestProject/src/screens/NewRecordingScreen.js
@@ -46,6 +46,7 @@ class NewRecordingScreen extends Component
         this.usedSensors = { "accelerometer": false, "gyroscope": false, "microphone": false };
 
         // Ensure the recording class has been initialised
+        // TODO: Change this to check whether a `Recording` instance has been passed in
         if (App.recording == null)
         {
             throw new Error("NewRecordingScreen.constructor: App.recording has not been initialised");
diff --git a/TestProject/src/screens/RecordingScreen.js b/TestProject/src/screens/RecordingScreen.js
index 22b03a90..bacc867e 100644
--- a/TestProject/src/screens/RecordingScreen.js
+++ b/TestProject/src/screens/RecordingScreen.js
@@ -100,6 +100,7 @@ class RecordingScreen extends Component
         console.log(this.state.checkedStatus[this.state.sensorNames[0]])
 
         // Ensure the recording class has been initialised
+        // TODO: Change this to check if a `Recording` instance has been passed in
         if (App.recording == null)
         {
             throw new Error('NewRecordingScreen.constructor: App.recording has not been initialised');
@@ -125,6 +126,7 @@ class RecordingScreen extends Component
             newLabel = label.labelName;
         }
         // Update the label
+        // TODO: Change this to use the current `Recording` instance
         App.recording.setLabel(newLabel);
         this.state.currentLabel = newLabel;
         // Output a debug message
@@ -158,8 +160,9 @@ class RecordingScreen extends Component
         const updateGraphData = () => {
             let maxPoints = 20;
             // Add a new point
-            let sample = App.recording.getSensorData(SensorType.MICROPHONE).getLatestSample();
-            // let sample = App.recording.getSensorData(SensorType.ACCELEROMETER).getLatestSample();
+            // TODO: Change these to get data from the current `Recording` instance
+            // let sample = App.recording.getSensorData(SensorType.MICROPHONE).getLatestSample();
+            let sample = App.recording.getSensorData(SensorType.ACCELEROMETER).getLatestSample();
             // let sample = App.recording.getSensorData(SensorType.GYROSCOPE).getLatestSample();
             // let sample = App.recording.getSensorData(SensorType.MAGNETOMETER).getLatestSample();
             // let sample = App.recording.getSensorData(SensorType.BAROMETER).getLatestSample();
diff --git a/TestProject/src/sensors/GenericTimeframe.js b/TestProject/src/sensors/GenericTimeframe.js
index a1af272a..1a57b2f1 100644
--- a/TestProject/src/sensors/GenericTimeframe.js
+++ b/TestProject/src/sensors/GenericTimeframe.js
@@ -1,20 +1,24 @@
 /* eslint-disable prettier/prettier */
 import SensorTimeframe from './SensorTimeframe';
+import SensorSample from "./SensorSample";
+import { getSensorFileName } from "../Sensors";
+import { appendFile } from "react-native-fs";
 
 export default class GenericTimeframe extends SensorTimeframe
 {
-    static warning = false; // TODO: Remove this later, it is only used to prevent the saveToCsv function from throwing a warning repeatedly
     /**
-     * @param initialSize The maximum number of data points stored in the timeframe. This should be the same as the number
-     *                    of data points shown in the graph.
-     * @param bufferSize The number of samples to store before it is saved to the file all at once. This is used to
-     *                   prevent samples being saved one at a time which adds a lot of extra overhead
-     * @param label      The label of the current timeframe (optional)
+     * @param recording     A reference to the recording class that this timeframe is stored under
+     * @param initialSize   The number of samples to store before auto-saving to file
+     * @param bufferSize    The number of samples to push to file at once
+     * @param type          The type of data stored in the timeframe eg. SensorTypes.ACCELEROMETER
+     * @param label         The initial label of the current timeframe (optional)
      */
-    constructor(initialSize, bufferSize, label = null)
+    constructor(recording, initialSize, bufferSize, type, label = null)
     {
-        super(initialSize, bufferSize);
+        super(recording, initialSize, bufferSize);
+        this.type = type;
         this.label = label;
+        this.filePath = this.recording.folderPath + getSensorFileName(this.type);
     }
 
     /**
@@ -29,13 +33,19 @@ export default class GenericTimeframe extends SensorTimeframe
     static moveCircularPointer(shiftCount, currentIndex, elementCount, size)
     {
         if (Math.abs(shiftCount) > elementCount)
-            {throw new Error('GenericTimeframe.moveCircularPointer: Attempted to shift the pointer ' + shiftCount +
-              ' space(s) but the array is only ' + elementCount + ' element(s) long');}
+        {
+            throw new Error('GenericTimeframe.moveCircularPointer: Attempted to shift the pointer ' + shiftCount +
+              ' space(s) but the array is only ' + elementCount + ' element(s) long');
+        }
 
         if (shiftCount > 0)
-            {return currentIndex + shiftCount < size ? currentIndex + shiftCount : currentIndex + shiftCount - size;}
+        {
+            return currentIndex + shiftCount < size ? currentIndex + shiftCount : currentIndex + shiftCount - size;
+        }
         else
-            {return currentIndex + shiftCount > -1 ? currentIndex + shiftCount : currentIndex + shiftCount + size;}
+        {
+            return currentIndex + shiftCount > -1 ? currentIndex + shiftCount : currentIndex + shiftCount + size;
+        }
     }
 
     /**
@@ -45,6 +55,12 @@ export default class GenericTimeframe extends SensorTimeframe
      */
     addSample(sample)
     {
+        // Make sure that the data is wrapped in a sample class
+        if (!(sample instanceof SensorSample))
+        {
+            throw new Error(this.constructor.name + '.addSample: Received an unwrapped sample.');
+        }
+
         // Pop the first sample and shift the array if at capacity
         if (this.dataSize === this.data.length) {this.popAndSave(1);}
 
@@ -58,12 +74,23 @@ export default class GenericTimeframe extends SensorTimeframe
     /**
      * Add multiple samples to the timeframe at once. This should only be called on the latest timeframe.
      * @param samples An array of samples to add to the timeframe
+     * @param wrapper A reference to a wrapper class (eg. MicSample, AccelerometerSample). This is only needed
+     *                if the data is not pre-wrapped in a Sample class
      */
-    addSamples(samples)
+    addSamples(samples, wrapper = null)
     {
+        // Make sure that the data is wrapped in a sample class
+        if (!(samples[0] instanceof SensorSample) && wrapper == null)
+        {
+            throw new Error(this.constructor.name + '.addSamples: Received an unwrapped sample with no reference to ' +
+                'a wrapper. Either pass in wrapped data or pass in a reference to the wrapper class.');
+        }
+
         for (let i = 0; i < samples.length; i++)
         {
-            this.addSample(samples[i]);
+            const sample = wrapper == null ? samples[i] : new wrapper(samples[i]);
+            // Wrap the sample if needed and add it to this timeframe
+            this.addSample(sample);
         }
     }
 
@@ -125,10 +152,9 @@ export default class GenericTimeframe extends SensorTimeframe
      */
     saveToCsv(samples)
     {
-        if (!GenericTimeframe.warning)
+        for (let i = 0; i < samples.length; i++)
         {
-            console.warn('GenericTimeframe.saveToCsv: Method has not been implemented. No data will be saved.');
-            GenericTimeframe.warning = true;
+            appendFile(this.filePath, samples[0].getData().toString() + ',' + this.label + '\n', 'utf8');
         }
     }
 
diff --git a/TestProject/src/sensors/Mic.js b/TestProject/src/sensors/Mic.js
index 6ad3a065..b5ad04c4 100644
--- a/TestProject/src/sensors/Mic.js
+++ b/TestProject/src/sensors/Mic.js
@@ -1,6 +1,7 @@
 /* eslint-disable prettier/prettier */
 import Sensor from './Sensor';
 import MicStream from 'react-native-microphone-stream';
+import { MicSample } from "../Sensors";
 
 export default class Mic extends Sensor
 {
@@ -12,7 +13,7 @@ export default class Mic extends Sensor
 
         function storeData(data) {
             // console.log("Just added a new sample");
-            dataStore[dataStore.length - 1].addSamples(data);
+            dataStore[dataStore.length - 1].addSamples(data, MicSample);
         }
 
         const micStream = MicStream.addListener((data) => {
diff --git a/TestProject/src/sensors/Sensor.js b/TestProject/src/sensors/Sensor.js
index 9c87a547..e9a120df 100644
--- a/TestProject/src/sensors/Sensor.js
+++ b/TestProject/src/sensors/Sensor.js
@@ -24,6 +24,7 @@ export default class Sensor
             const child = Object.getPrototypeOf(this);
             // A list of functions that needs to be implemented
             let functions = [
+                {name: 'constructor', params: ['dataStore']},
                 {name: 'enable', params: ['sampleRate']},
                 {name: 'disable', params: []},
                 {name: 'updateSampleRate', params: ['sampleRate']},
diff --git a/TestProject/src/sensors/SensorTimeframe.js b/TestProject/src/sensors/SensorTimeframe.js
index 9f73e5bc..889f8b50 100644
--- a/TestProject/src/sensors/SensorTimeframe.js
+++ b/TestProject/src/sensors/SensorTimeframe.js
@@ -1,15 +1,38 @@
 /* eslint-disable prettier/prettier */
 import { ErrorChecking } from '../Errors';
+import Recording from "../Recording";
 
 export default class SensorTimeframe
 {
-    constructor(initialSize, bufferSize)
+    /**
+     * Initialise everything
+     *
+     * @param recording     A reference to the recording class that this timeframe is stored under
+     * @param initialSize   The number of samples to store before auto-saving to file
+     * @param bufferSize    The number of samples to push to file at once
+     */
+    constructor(recording, initialSize, bufferSize)
     {
+        // Make sure the correct parameters are passed in
+        if (!(recording instanceof Recording))
+        {
+            throw new Error('SensorTimeframe.constructor(): A valid reference to the recording instance must be passed in.');
+        }
+        else if (!Number.isInteger(initialSize) || initialSize < 1)
+        {
+            throw new Error('SensorTimeframe.constructor(): A valid initial storage size must be specified.');
+        }
+        else if (!Number.isInteger(bufferSize) || bufferSize < 1)
+        {
+            throw new Error('SensorTimeframe.constructor(): A valid buffer size size must be specified.');
+        }
+
         this.data = new Array(initialSize);
         this.dataSize = 0;
         this.dataPointer = 0;
         this.exportBuffer = new Array(bufferSize);
-        this.bufferSize = 0;
+        this.bufferSize = 0; // The number of elements actually in the buffer
+        this.recording = recording;
 
         /*** Everything below this is for checking that child classes implement functions correctly */
         // Only run the checks if we're allowed to
@@ -27,7 +50,7 @@ export default class SensorTimeframe
             const child = Object.getPrototypeOf(this);
             // A list of functions that needs to be implemented
             let functions = [
-                {name: 'constructor', params: ['initialSize', 'bufferSize']},
+                {name: 'constructor', params: ['recording', 'initialSize', 'bufferSize']},
                 {name: 'addSample', params: ['sample']},
                 {name: 'popAndSave', params: ['sampleCount']},
                 {name: 'saveToCsv', params: ['samples']},
